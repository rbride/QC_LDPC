https://www.zeroasic.com/blog/opensta-release Static timing analysis tools

If you don't need to write data at the same time you're reading, you can use a dual port RAM to reduce the number of duplicated RAMs by half.
 Also if you're able to control where the data is stored, you can use banking which would allow you to use 4 smaller BRAMs
 . If you don't need max throughput (i.e. you're reading in a bursty fashion), you could use banking and a small queue. 
 One other solution is to use a higher clock frequency for the BRAM, but if the rest of your system is already running fast you probably
 won't get much improvement from that as the max frequency for BRAM isn't much faster than the max frequency 
 you could run heavily pipelined logic at. Otherwise, if you need to access 4 values every single clock cycle and their
 locations can be anywhere in memory, you'd need to just duplicate RAMs.

This can be seen in the new Cyclical shifter function. We need a defined width that defines
the width of the registers

I wrote the boilerplate unconnected code for the most part or the surrounding code for the 
Function and stuff. But now I need to hook it up 


    // genvar c;
    // generate
    // for (c = 0; c < ROWBITS; c = c + 1) begin: test
    //     always @(posedge sysclk) begin
    //         temp[c] <= 1'b0;
    //     end
    // end
    // endgenerate
    // Generates the following 4
    //always @(posedge sysclk) temp[0] <= 1'b0;
    //always @(posedge sysclk) temp[1] <= 1'b0;
    //always @(posedge sysclk) temp[2] <= 1'b0;
    //always @(posedge sysclk) temp[3] <= 1'b0;
    
    //Assert the Reset of the Accum Registers in a generic Always block 

    // Given the undefined (See to tired to remember and look it up) Nature 
// Of the shift operator, define in test bench a check that checks to see
// that the shift is actually occuring the correct number of times in whatever
// since the input isn't an int
// wacky crazy simulator and systhesis that occurs should be fine


// assert that at no point the memory data is unknown because 
// the barrel shift function by design cast to int and it is necessary that 
// there won't be any X or Z values contained 
//  assert (!$isunknown(signal))
//        a = signal;
// else
//   $error("signal is unknown");



//Note the design is mostly suitable for only the highest rate at this point
//After completetion consider restructuring the Memory so that it compacts given
//inputs for slower rates. 



  // -------------------------------------------------------------------------
    // Memory block Module Generated based on parameter input for the matrix 
    // prototype tables provided in the Standard. 
    // Potential Expand to: Accept parameters for LUT Or BRAM based on a parameter
    // to test area and speed tradeoffs of the two (would change timing), however,
    // by concating columns together, I would be able to reduce number of cycles
    // while creating a somewhat more generic circuit that is potentially capable,
    // of on the fly swithching between code lenghts and maybe even rates. 
    // -------------------------------------------------------------------------

Currently the hook up of the actual encoder to the memory controller makes no sense
its not paramatized correctly. It needs to be changed so that there are generation characteristics
that depict and determine if the actual structure itself is aiming to go for multiple speeds or 
if the goal is a single speed, because the difference is that each constraint will define a 
different structure.

The design either needs to instatiate to a design that either performs the desired single rate of
encoding, or one that instatiates a larger design that has signal interface/pathways fitting
the largest possible data width and encoding stuff, and then utilize a smaller section of
those interfaces when using a slower/lower encoding selection. 


//===================================================
// ROM example with parameter-driven memory layout
//===================================================

module rom_example #(
    parameter int WIDTH       = 8,      
    parameter int DEPTH       = 16,     // number of rows
    parameter int MEM_LAYOUT  = 0       // 0 = 1D, 1 = 2D
)(
    input  logic [$clog2(DEPTH)-1:0] addr,
    input  logic [2:0] col,           // only used for 2D
    output logic [WIDTH-1:0] data_out
);

    // ----------------------------
    // Generate ROM depending on MEM_LAYOUT
    // ----------------------------
    generate
        if (MEM_LAYOUT == 0) begin : gen_1D
            // 1D ROM
            logic [WIDTH-1:0] rom [0:DEPTH-1];

            // Example initialization
            initial begin
                for (int i=0; i<DEPTH; i=i+1) rom[i] = i;
            end
        end else begin : gen_2D
            // 2D ROM
            logic [WIDTH-1:0] rom [0:DEPTH-1][0:4]; // example 5 columns

            // Example initialization
            initial begin
                for (int i=0; i<DEPTH; i=i+1)
                    for (int j=0; j<5; j=j+1)
                        rom[i][j] = i*10 + j;
            end
        end
    endgenerate

    // ----------------------------
    // Function to abstract ROM access
    // ----------------------------
    function logic [WIDTH-1:0] rom_read(input int r, input int c);
        // Must be elaboration-time constant (MEM_LAYOUT is a parameter)
        if (MEM_LAYOUT == 0)
            rom_read = gen_1D.rom[r];        // 1D access
        else
            rom_read = gen_2D.rom[r][c];     // 2D access
    endfunction

    // ----------------------------
    // Use the function to drive output
    // ----------------------------
    assign data_out = rom_read(addr, col);

endmodule


`define NUM_SUPPORTED_BLK_LEN                   3
`define NUM_INFO_BLKS_PER_CODE_BLK              20
`define NUM_PARITY_BLKS_PER_CODE_BLK            4
`define HIGHEST_SUPPORTED_Z_VAL                 81
// For single rate LUT Highest Z supported is also the only Z supported and used   
`define ROM_TYPE                                1

/*verilator split_var*/  ; 